#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    IRsensorL,      sensorReflection)
#pragma config(Sensor, in2,    IRsensorR,      sensorReflection)
#pragma config(Sensor, dgtl1,  LEDred,         sensorDigitalOut)
#pragma config(Sensor, dgtl7,  buttonL,        sensorTouch)
#pragma config(Sensor, dgtl8,  buttonR,        sensorTouch)
#pragma config(Sensor, dgtl9,  LHLimit,        sensorTouch)
#pragma config(Sensor, dgtl10, RHLimit,        sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           drive,         tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port2,           drop,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          turn,          tmotorVex393_HBridge, openLoop, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int IRmax=0;				//Max level of detection of IR light
int IRmin=4096;					//Min level of detection of IR light
int IRdif=0;
int diffthresh = 200;  // set to threshold required for 1m detection

bool checklightR(){

	int lightLevel = SensorValue[IRsensorR];

	bool returnValue;

	// Check if 50 msecs have elapsed.
	if ( time1[T1] > 100 )  {

		// 50 msecs have elapsed.  Compute change in light level.
		IRdif = IRmax - IRmin;

		// Reset calculation for next 50 msecs.
		IRmax = 0;
		IRmin = 4096;
		clearTimer(T1);

		} else {

		// Check for new minimum/maximum light levels.
		if ( lightLevel < IRmin ) {
			IRmin = lightLevel;
			} else if ( lightLevel > IRmax ) {
			IRmax = lightLevel;
		}
	}

	// Check if light level difference over threshold.
	if ( IRdif > diffthresh ) {
		returnValue = true;
		} else {
		returnValue = false;
	}

	return(returnValue);
}

void scan360R(){
	resetMotorEncoder(turn);
	resetMotorEncoder(drive);
	motor[turn]=-25;      							//Turn wheel 90 degrees
	while (true){
		if(getMotorEncoder(turn)<=-250) {	//change "300" to allow for motor turn 360 degrees
			motor[turn]=0;
			break;
		}
	}
	motor[drive]=52;
	while(true){
		bool offon = checklightR();							//change drive motor to make slow 360 degree scan
		//all values can be changed to allow for proper turn
		if (offon==1){
			motor[drive]=-90;
			delay(100);
			motor[drive]=0;
			SensorValue[LEDred]=1;
			break;
		}
	}//change drive motor to make slow 360 degree scan
	//all values can be changed to allow for proper turn
	motor[turn]=25;									//Turns wheel back
	while (true) {
		if (getMotorEncoder(turn)==0){
			motor[turn]=0;
			break;
		}
	}
}



bool checklightL(){

	int lightLevel = SensorValue[IRsensorL];

	bool returnValue;

	// Check if 50 msecs have elapsed.
	if ( time1[T1] > 100 )  {

		// 50 msecs have elapsed.  Compute change in light level.
		IRdif = IRmax - IRmin;

		// Reset calculation for next 50 msecs.
		IRmax = 0;
		IRmin = 4096;
		clearTimer(T1);

		} else {

		// Check for new minimum/maximum light levels.
		if ( lightLevel < IRmin ) {
			IRmin = lightLevel;
			} else if ( lightLevel > IRmax ) {
			IRmax = lightLevel;
		}
	}

	// Check if light level difference over threshold.
	if ( IRdif > diffthresh ) {
		returnValue = true;
		} else {
		returnValue = false;
	}

	return(returnValue);
}

void scan360L(){
	resetMotorEncoder(turn);
	resetMotorEncoder(drive);
	motor[turn]=25;      							//Turn wheel 90 degrees
	while (true){
		if(getMotorEncoder(turn)>=250) {	//change "300" to allow for motor turn 360 degrees
			motor[turn]=0;
			break;
		}
	}
	motor[drive]=52;
	while(true){
		bool offon = checklightL();							//change drive motor to make slow 360 degree scan
		//all values can be changed to allow for proper turn
		if (offon==1){
			motor[drive]=-90;
			delay(100);
			motor[drive]=0;
			SensorValue[LEDred]=1;
			break;
		}
	}//change drive motor to make slow 360 degree scan
	//all values can be changed to allow for proper turn
	motor[turn]=-25;									//Turns wheel back
	while (true) {
		if (getMotorEncoder(turn)==0){
			motor[turn]=0;
			break;
		}
	}
}



task main()
{
	SensorValue[LEDred]=0;
	SensorValue[buttonR]=0;
	SensorValue[buttonL]=0;
	while(true){
		if(SensorValue[buttonR]==1){
			SensorValue[LEDred]=0;
			scan360R();
			SensorValue[buttonR]=0;
			SensorValue[buttonL]=0;
		}
		if(SensorValue[buttonL]==1){
			SensorValue[LEDred]=0;
			scan360L();
			SensorValue[buttonR]=0;
			SensorValue[buttonL]=0;
		}
	}
}
